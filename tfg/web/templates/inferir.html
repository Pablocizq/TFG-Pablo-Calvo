<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inferir Metadatos</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'web/css/inferir.css' %}?v=20251124">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>

<body>
    <header class="header">
        <a href="{% url 'inicio' %}" class="home-btn" title="Inicio">üè†</a>
        <h1>Elige c√≥mo inferir tus metadatos</h1>
        <button class="perfil-btn">üë§</button>
    </header>

    <main class="contenedor">
        <section class="panel">
            <p class="intro">
                Selecciona qu√© propiedades de tus datos deben servir como referencia para que la IA
                genere autom√°ticamente el t√≠tulo, la descripci√≥n, el tema y el resto de campos.
                Las columnas se generan a partir de los ficheros que cargaste en ¬´Crear conjunto¬ª.
            </p>

            <div id="alerta" class="alerta" hidden></div>

            <div id="campos-container" class="campos">
                {% for campo in campos_inferencia %}
                <div class="campo-inferencia" data-campo="{{ campo.id }}">
                    <div class="campo-info">
                        <h3>{{ campo.nombre }}</h3>
                        <p>{{ campo.descripcion }}</p>
                    </div>
                    <div class="opciones" data-options-for="{{ campo.id }}">
                        <span class="placeholder">Buscando columnas disponibles‚Ä¶</span>
                    </div>
                </div>
                {% endfor %}
            </div>

            <div class="acciones">
                <a class="btn secundario"
                    href="{% url 'metadatos' %}{% if query_params %}?{{ query_params }}{% endif %}">
                    ‚üµ Volver a metadatos
                </a>
                <button id="inferir-btn" class="btn primario" type="button">Inferir metadatos</button>
            </div>

            <div id="resultado-panel" class="resultado-panel" hidden>
                <h3>Resumen de selecci√≥n</h3>
                <pre id="resultado-json"></pre>
                <p class="nota">
                    Pr√≥ximamente esta selecci√≥n se enviar√° autom√°ticamente al servicio de IA.
                </p>
            </div>
        </section>
    </main>

    {% load static %}
    {{ campos_inferencia|json_script:"campos-data" }}
    <script>
        (function () {
            const campos = JSON.parse(document.getElementById('campos-data').textContent || '[]');
            const datasetRaw = sessionStorage.getItem('datasetFiles');
            const alerta = document.getElementById('alerta');
            const contenedores = document.querySelectorAll('[data-options-for]');
            const inferirBtn = document.getElementById('inferir-btn');
            const resultadoPanel = document.getElementById('resultado-panel');
            const resultadoJson = document.getElementById('resultado-json');

            if (!datasetRaw) {
                alerta.textContent = 'No encontramos ficheros cargados. Vuelve a ¬´Crear conjunto¬ª y selecciona tus datos antes de inferir.';
                alerta.hidden = false;
                contenedores.forEach(c => c.innerHTML = '<span class="placeholder">Sin columnas disponibles</span>');
                inferirBtn.disabled = true;
                return;
            }

            const datasetFiles = JSON.parse(datasetRaw);
            const columnas = extraerColumnas(datasetFiles);

            if (!columnas.length) {
                alerta.textContent = 'No pudimos identificar propiedades en los datos cargados. Comprueba que el formato sea JSON, RDF-Turtle o RDF-XML.';
                alerta.hidden = false;
                contenedores.forEach(c => c.innerHTML = '<span class="placeholder">Sin columnas detectadas</span>');
            } else {
                alerta.hidden = true;
                contenedores.forEach(container => {
                    const campoId = container.dataset.optionsFor;
                    container.innerHTML = '';
                    columnas.forEach(col => {
                        const id = `${campoId}-${col.replace(/[^a-zA-Z0-9_-]/g, '').toLowerCase()}`;
                        const label = document.createElement('label');
                        label.className = 'opcion-columna';
                        label.innerHTML = `
                        <input type="checkbox" name="${campoId}[]" value="${col}">
                        <span>${col}</span>
                    `;
                        container.appendChild(label);
                    });
                });
            }

            inferirBtn.addEventListener('click', () => {
                const resultados = {};
                campos.forEach(campo => {
                    const seleccionadas = Array.from(document.querySelectorAll(`input[name="${campo.id}[]"]:checked`))
                        .map(el => el.value);
                    resultados[campo.nombre] = seleccionadas;
                });

                resultadoJson.textContent = JSON.stringify(resultados, null, 2);
                resultadoPanel.hidden = false;
                alert('Selecci√≥n registrada. La integraci√≥n con el servicio de IA se a√±adir√° pr√≥ximamente.');
            });

            function extraerColumnas(files) {
                const set = new Set();
                files.forEach(file => {
                    const texto = dataUrlToText(file.content || '');
                    if (!texto) return;
                    const tipo = (file.type || '').toLowerCase();
                    const nombre = (file.name || '').toLowerCase();
                    let props = [];

                    // Detectar formato Turtle
                    if (tipo.includes('turtle') || nombre.endsWith('.ttl') || nombre.endsWith('.turtle')) {
                        props = extraerTurtle(texto);
                    }
                    // Detectar JSON
                    else if (tipo.includes('json') || nombre.endsWith('.json')) {
                        props = extraerJson(texto);
                    }
                    // Detectar XML/RDF-XML
                    else if (tipo.includes('xml') || tipo.includes('rdf') || nombre.endsWith('.xml') || nombre.endsWith('.rdf')) {
                        props = extraerXml(texto);
                    }
                    // Fallback: intentar todos los formatos
                    else {
                        props = extraerJson(texto);
                        if (!props.length) props = extraerTurtle(texto);
                        if (!props.length) props = extraerXml(texto);
                    }
                    props.forEach(p => set.add(p));
                });
                return Array.from(set).slice(0, 60); // limitar para mantener la UI ordenada
            }

            function dataUrlToText(dataUrl) {
                if (!dataUrl) return '';
                const base64Index = dataUrl.indexOf('base64,');
                if (base64Index === -1) return '';
                const base64 = dataUrl.substring(base64Index + 7);
                try {
                    const binary = atob(base64);
                    const bytes = new Uint8Array(binary.length);
                    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
                    return new TextDecoder('utf-8', { fatal: false }).decode(bytes);
                } catch (err) {
                    console.warn('No se pudo decodificar el archivo', err);
                    return '';
                }
            }

            function extraerJson(texto) {
                try {
                    const data = JSON.parse(texto);
                    const set = new Set();
                    const recorrer = valor => {
                        if (Array.isArray(valor)) {
                            valor.forEach(recorrer);
                        } else if (valor && typeof valor === 'object') {
                            Object.keys(valor).forEach(key => {
                                set.add(formatearNombre(key));
                                recorrer(valor[key]);
                            });
                        }
                    };
                    recorrer(data);
                    return Array.from(set);
                } catch {
                    return [];
                }
            }

            function extraerTurtle(texto) {
                try {
                    const set = new Set();

                    // Patr√≥n 1: Predicados con literales entre comillas
                    // Ejemplo: dct:title "Mi t√≠tulo"
                    const literalPattern = /([a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+)\s+["']/g;
                    let match;
                    while ((match = literalPattern.exec(texto)) !== null) {
                        const predicado = match[1];
                        const partes = predicado.split(':');
                        if (partes.length === 2) {
                            set.add(formatearNombre(partes[1]));
                        }
                    }

                    // Patr√≥n 2: Predicados con URIs completas o recursos
                    // Ejemplo: dct:subject <http://...>
                    const uriPattern = /([a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+)\s+<[^>]+>/g;
                    while ((match = uriPattern.exec(texto)) !== null) {
                        const predicado = match[1];
                        const partes = predicado.split(':');
                        if (partes.length === 2) {
                            set.add(formatearNombre(partes[1]));
                        }
                    }

                    // Patr√≥n 3: Predicados seguidos de blank nodes o identificadores
                    // Ejemplo: dcat:theme [ ... ] o dcat:distribution _:b1
                    const blankPattern = /([a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+)\s+[\[_]/g;
                    while ((match = blankPattern.exec(texto)) !== null) {
                        const predicado = match[1];
                        const partes = predicado.split(':');
                        if (partes.length === 2) {
                            set.add(formatearNombre(partes[1]));
                        }
                    }

                    // Patr√≥n 4: Capturar predicados con literales tipados
                    // Ejemplo: dct:issued "2023-01-01"^^xsd:date
                    const typedLiteralPattern = /([a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+)\s+"[^"]*"\^\^/g;
                    while ((match = typedLiteralPattern.exec(texto)) !== null) {
                        const predicado = match[1];
                        const partes = predicado.split(':');
                        if (partes.length === 2) {
                            set.add(formatearNombre(partes[1]));
                        }
                    }

                    // Patr√≥n 5: Predicados con literales de idioma
                    // Ejemplo: rdfs:label "Etiqueta"@es
                    const langLiteralPattern = /([a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+)\s+"[^"]*"@[a-z]{2}/g;
                    while ((match = langLiteralPattern.exec(texto)) !== null) {
                        const predicado = match[1];
                        const partes = predicado.split(':');
                        if (partes.length === 2) {
                            set.add(formatearNombre(partes[1]));
                        }
                    }

                    return Array.from(set);
                } catch (err) {
                    console.warn('Error extrayendo propiedades Turtle:', err);
                    return [];
                }
            }

            function extraerXml(texto) {
                try {
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(texto, 'application/xml');
                    if (doc.getElementsByTagName('parsererror').length) return [];

                    const nombres = new Set();

                    // Elementos estructurales de RDF que debemos ignorar
                    const elementosIgnorar = new Set([
                        'rdf:RDF', 'rdf:Description', 'rdf:Bag', 'rdf:Seq', 'rdf:Alt',
                        'rdf:Statement', 'rdf:Property', 'rdf:List', 'RDF', 'Description',
                        'Bag', 'Seq', 'Alt', 'Statement', 'Property', 'List'
                    ]);

                    // Atributos RDF que debemos ignorar ya que son estructurales
                    const atributosIgnorar = new Set([
                        'rdf:about', 'rdf:resource', 'rdf:nodeID', 'rdf:datatype',
                        'rdf:parseType', 'xmlns', 'xmlns:rdf', 'xmlns:dct', 'xmlns:dcat',
                        'xmlns:foaf', 'xmlns:dc', 'xmlns:dcterms', 'about', 'resource',
                        'nodeID', 'datatype', 'parseType'
                    ]);

                    // Namespaces comunes en RDF que S√ç queremos capturar como predicados
                    const namespacesRelevantes = [
                        'dct:', 'dcat:', 'foaf:', 'dc:', 'dcterms:', 'skos:',
                        'rdfs:', 'owl:', 'vcard:', 'adms:', 'schema:'
                    ];

                    doc.querySelectorAll('*').forEach(node => {
                        const nodeName = node.nodeName;

                        // Verificar si el elemento es un predicado RDF relevante
                        const esPredicado = namespacesRelevantes.some(ns => nodeName.startsWith(ns))
                            || (nodeName.includes(':') && !elementosIgnorar.has(nodeName));

                        // Si el nodo es un predicado (no un elemento estructural)
                        if (esPredicado && !elementosIgnorar.has(nodeName)) {
                            // Extraer solo la parte del predicado despu√©s del namespace
                            if (nodeName.includes(':')) {
                                const partes = nodeName.split(':');
                                if (partes.length === 2) {
                                    nombres.add(formatearNombre(partes[1]));
                                }
                            }
                        }

                        // Capturar tambi√©n los hijos directos de rdf:Description que son predicados
                        if (node.parentNode &&
                            (node.parentNode.nodeName === 'rdf:Description' ||
                                node.parentNode.nodeName === 'Description')) {
                            if (!elementosIgnorar.has(nodeName) && nodeName.includes(':')) {
                                const partes = nodeName.split(':');
                                if (partes.length === 2) {
                                    nombres.add(formatearNombre(partes[1]));
                                }
                            }
                        }

                        // Capturar atributos que sean propiedades RDF (excluyendo los estructurales)
                        Array.from(node.attributes || []).forEach(attr => {
                            const attrName = attr.name;
                            if (!atributosIgnorar.has(attrName) &&
                                !attrName.startsWith('xmlns') &&
                                attrName.includes(':')) {
                                const partes = attrName.split(':');
                                if (partes.length === 2) {
                                    nombres.add(formatearNombre(partes[1]));
                                }
                            }
                        });
                    });

                    return Array.from(nombres);
                } catch (err) {
                    console.warn('Error extrayendo propiedades XML/RDF:', err);
                    return [];
                }
            }

            function formatearNombre(nombre) {
                if (!nombre) return '';
                return nombre.replace(/[_-]/g, ' ').trim();
            }
        })();
    </script>
</body>

</html>