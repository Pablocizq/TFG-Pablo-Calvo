<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metadatos del Conjunto</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'web/css/metadatos.css' %}?v=20251110">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
</head>

<body>
    <header class="header">
        <!-- Bot贸n/铆cono HOME a la izquierda que redirige a la vista 'inicio' -->
        <a href="{% url 'inicio' %}" class="home-btn" title="Inicio"></a>
        <h1>Metadatos</h1>
        <button class="perfil-btn"></button>
    </header>

    <div class="acciones-secundarias">
        <button type="button" id="descargar-turtle" class="descargar-turtle-btn">Descargar Turtle</button>
        <a href="{% url 'inferir' %}?name={{ name|urlencode }}&formato={{ formato|urlencode }}&metadata_url={{ metadata_url|urlencode }}"
            class="inferir-ia-btn" title="Seleccionar columnas para la inferencia autom谩tica">
            Inferir con IA
        </a>
    </div>

    <main class="contenedor">
        <!-- El formulario POST enviar谩 a la vista 'crear_conjunto' para crear el dataset
             usando el campo oculto 'name' que recibimos por query param desde
             la p谩gina de creaci贸n. -->
        <form class="formulario" method="post" action="{% url 'crear_conjunto' %}">
            {% csrf_token %}
            <input type="hidden" name="name" value="{{ name|default:'' }}">
            <input type="hidden" name="formato" value="{{ formato|default:'' }}">
            <input type="hidden" name="url_metadatos" value="{{ metadata_url|default:'' }}">
            <input type="hidden" name="metadata_content" id="metadata-content-field" value="">
            <!-- Indica a la vista que debe volver a renderizar metadatos con mensajes -->
            <input type="hidden" name="next" value="metadatos">

            {% if success %}
            <div class="notificacion notificacion-exito">{{ success }}</div>
            {% endif %}
            {% if error %}
            <div class="notificacion notificacion-error">{{ error }}</div>
            {% endif %}

            <!-- ICONO DESCARGA
            <div class="acciones-superiores">
                <button type="button" class="btn-icono descargar" title="Descargar metadatos">猬锔</button>
                <button type="button" class="btn-icono editar" title="Editar metadatos">锔</button>
            </div>-->

            <div class="grid-campos">
                <div class="campo">
                    <label>Identificador:</label>
                    <input type="text" name="identificador" readonly
                        placeholder="Se genera autom谩ticamente al publicar en CKAN">
                </div>

                <div class="campo">
                    <label>T铆tulo:</label>
                    <input type="text" name="titulo" placeholder="T铆tulo del conjunto">
                </div>

                <div class="campo campo-largo">
                    <label>Descripci贸n:</label>
                    <textarea name="descripcion" rows="3" placeholder="Descripci贸n del conjunto de datos"></textarea>
                </div>

                <div class="campo">
                    <label>Tipo:</label>
                    <input type="text" name="dcat_type" placeholder="Tipo de conjunto (dataset, service...)">
                </div>

                <div class="campo">
                    <label>Idioma:</label>
                    <input type="text" name="idioma" placeholder="Ej. Espa帽ol">
                </div>

                <div class="campo">
                    <label>Tema:</label>
                    <input type="text" name="tema" placeholder="Ej. Medio ambiente, educaci贸n...">
                </div>

                <div class="campo">
                    <label>Palabras clave:</label>
                    <input type="text" name="palabras_clave"
                        placeholder="Ej. datos abiertos, sostenibilidad, energ铆a renovable">
                </div>

                <div class="campo">
                    <label>Extensi贸n temporal:</label>
                    <input type="text" name="extension_temporal" placeholder="Ej. 2020 - 2025">
                </div>

                <div class="campo">
                    <label>Extensi贸n espacial:</label>
                    <input type="text" name="extension_espacial" placeholder="Ej. Espa帽a, Europa...">
                </div>

                <div class="campo">
                    <label>URL de descarga:</label>
                    <input type="url" name="url_descarga" placeholder="https://...">
                </div>

                <div class="campo">
                    <label>Fecha de publicaci贸n:</label>
                    <input type="date" name="issued">
                </div>

                <div class="campo">
                    <label>ltima modificaci贸n:</label>
                    <input type="date" name="modificado">
                </div>

                <div class="campo">
                    <label>Publicador:</label>
                    <input type="text" name="publisher_name" placeholder="Nombre del publicador">
                </div>

                <div class="campo">
                    <label>URL de acceso:</label>
                    <input type="url" name="url_acceso" placeholder="https://...">
                </div>

                <div class="campo">
                    <label>Licencia:</label>
                    <input type="text" name="licencia" placeholder="Tipo de licencia (CC-BY, etc.)">
                </div>

                <div class="campo">
                    <label>Derechos:</label>
                    <input type="text" name="derechos" placeholder="Descripci贸n de derechos o uso">
                </div>

                <div class="campo campo-largo">
                    <label>Descripci贸n de la distribuci贸n:</label>
                    <textarea name="descripcion_distribucion" rows="2"
                        placeholder="Detalles sobre la distribuci贸n de los datos"></textarea>
                </div>
            </div>

            <div class="botones">
                <!-- Bot贸n para integraci贸n CKAN (no env铆a el formulario aqu铆) -->
                <button type="button" class="btn crear">CREAR DATASET EN CKAN</button>
                <!-- Este bot贸n s铆 hace POST a la vista 'crear_conjunto' y guarda el dataset -->
                <button type="submit" class="btn guardar">GUARDAR CONJUNTO</button>
            </div>
        </form>
    </main>
    <script>
        // Oculta notificaciones autom谩ticamente tras 4s
        (function () {
            const nots = document.querySelectorAll('.notificacion');
            if (!nots) return;
            setTimeout(() => nots.forEach(n => n.style.display = 'none'), 10000);
        })();

        // Recupera el contenido del fichero de metadatos guardado en sessionStorage
        (function () {
            const field = document.getElementById('metadata-content-field');
            const stored = sessionStorage.getItem('metadataFileContent');
            if (field && stored !== null) {
                field.value = stored;
            }

            // Prefill ALL AI-generated metadata fields
            const aiMetadata = {
                titulo: sessionStorage.getItem('aiGeneratedTitulo'),
                descripcion: sessionStorage.getItem('aiGeneratedDescripcion'),
                tema: sessionStorage.getItem('aiGeneratedTema'),
                palabras_clave: sessionStorage.getItem('aiGeneratedPalabrasclave'),
                extension_temporal: sessionStorage.getItem('aiGeneratedExtensiontemporal'),
                extension_espacial: sessionStorage.getItem('aiGeneratedExtensionespacial')
            };

            Object.entries(aiMetadata).forEach(([fieldName, value]) => {
                if (value) {
                    const input = document.querySelector(`[name="${fieldName}"]`);
                    if (input && (!input.value || !input.value.trim())) {
                        input.value = value;
                        input.style.background = '#e0f2fe';
                        setTimeout(() => input.style.background = '', 2000);
                    }
                    // Clear from sessionStorage
                    const keyName = 'aiGenerated' + fieldName.charAt(0).toUpperCase() + fieldName.slice(1).replace(/_/g, '');
                    sessionStorage.removeItem(keyName);
                }
            });

            const form = document.querySelector('.formulario');
            const tryPrefill = () => {
                if (!form || !stored) return;

                let applied = false;

                const setValueIfEmpty = (name, value) => {
                    if (value === undefined || value === null) return;
                    const strValue = String(value).trim();
                    if (!strValue) return;
                    const input = form.querySelector(`[name="${name}"]`);
                    if (!input) return;
                    if (input.value && input.value.trim()) return;
                    input.value = strValue;
                    applied = true;
                };

                const normalize = val => {
                    if (val === undefined || val === null) return '';
                    if (Array.isArray(val)) return val.length ? normalize(val[0]) : '';
                    if (typeof val === 'object') return '';
                    return String(val).trim();
                };

                const fieldMapping = {
                    identificador: ['identificador', 'identifier', 'id'],
                    titulo: ['titulo', 'title', 'name'],
                    descripcion: ['descripcion', 'description', 'abstract'],
                    dcat_type: ['dcat_type', 'type'],
                    idioma: ['idioma', 'language', 'lang'],
                    tema: ['tema', 'theme', 'subject'],
                    extension_temporal: ['extension_temporal', 'temporal', 'temporal_coverage'],
                    extension_espacial: ['extension_espacial', 'spatial', 'spatial_coverage', 'location'],
                    url_descarga: ['url_descarga', 'download_url', 'downloadurl'],
                    issued: ['issued', 'fecha_publicacion', 'published'],
                    modificado: ['modificado', 'modified', 'updated'],
                    publisher_name: ['publisher_name', 'publisher', 'creator'],
                    url_acceso: ['url_acceso', 'access_url', 'accessurl'],
                    formato: ['formato', 'format', 'media_type'],
                    licencia: ['licencia', 'license'],
                    derechos: ['derechos', 'rights'],
                    descripcion_distribucion: ['descripcion_distribucion', 'distribution_description', 'distribution']
                };

                const formatHint = (form.querySelector('[name="formato"]')?.value || '').toLowerCase();

                const applyFromObject = obj => {
                    const lowerKeys = Object.fromEntries(
                        Object.entries(obj).map(([k, v]) => [k.toLowerCase(), v])
                    );
                    Object.entries(fieldMapping).forEach(([fieldName, keys]) => {
                        const matchKey = keys.find(k => lowerKeys.hasOwnProperty(k));
                        if (matchKey) {
                            setValueIfEmpty(fieldName, normalize(lowerKeys[matchKey]));
                        }
                    });
                };

                const attemptJson = () => {
                    try {
                        const data = JSON.parse(stored);
                        if (data && typeof data === 'object') {
                            applyFromObject(data);
                            return applied;
                        }
                        return false;
                    } catch (err) {
                        return false;
                    }
                };

                const attemptXml = () => {
                    try {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(stored, 'application/xml');
                        if (xmlDoc.getElementsByTagName('parsererror').length) return false;

                        const selectorMap = {
                            identificador: ['dct\\:identifier', 'dc\\:identifier', 'identifier', 'rdf\\:about'],
                            titulo: ['dct\\:title', 'dc\\:title', 'title', 'rdfs\\:label'],
                            descripcion: ['dct\\:description', 'dc\\:description', 'description'],
                            dcat_type: ['dcat\\:type', 'type'],
                            idioma: ['dct\\:language', 'dc\\:language', 'language'],
                            tema: ['dcat\\:theme', 'theme', 'dct\\:subject'],
                            extension_temporal: ['dct\\:temporal', 'temporal'],
                            extension_espacial: ['dct\\:spatial', 'spatial'],
                            url_descarga: ['dcat\\:downloadURL', 'downloadURL', 'dcat\\:downloadurl'],
                            issued: ['dct\\:issued', 'issued'],
                            modificado: ['dct\\:modified', 'modified'],
                            publisher_name: ['dct\\:publisher', 'publisher'],
                            url_acceso: ['dcat\\:accessURL', 'accessURL', 'dcat\\:accessurl'],
                            formato: ['dct\\:format', 'format'],
                            licencia: ['dct\\:license', 'license'],
                            derechos: ['dct\\:rights', 'rights'],
                            descripcion_distribucion: ['dcat\\:distribution', 'distribution']
                        };

                        const getText = selector => {
                            const node = xmlDoc.querySelector(selector);
                            if (!node) return '';
                            if (node.textContent && node.textContent.trim()) return node.textContent.trim();
                            const res = node.getAttribute('rdf:resource') || node.getAttribute('rdf:about') || node.getAttribute('resource');
                            return res ? res.trim() : '';
                        };

                        Object.entries(selectorMap).forEach(([fieldName, selectors]) => {
                            selectors.some(selector => {
                                const value = getText(selector);
                                if (value) {
                                    setValueIfEmpty(fieldName, value);
                                    return true;
                                }
                                return false;
                            });
                        });
                        return applied;
                    } catch (err) {
                        return false;
                    }
                };

                const attemptTurtle = () => {
                    const turtleMap = {
                        identificador: ['dct:identifier', 'dc:identifier'],
                        titulo: ['dct:title', 'dc:title', 'rdfs:label'],
                        descripcion: ['dct:description', 'dc:description'],
                        dcat_type: ['dcat:type'],
                        idioma: ['dct:language', 'dc:language'],
                        tema: ['dcat:theme', 'dct:subject'],
                        extension_temporal: ['dct:temporal'],
                        extension_espacial: ['dct:spatial'],
                        url_descarga: ['dcat:downloadURL'],
                        issued: ['dct:issued'],
                        modificado: ['dct:modified'],
                        publisher_name: ['dct:publisher'],
                        url_acceso: ['dcat:accessURL'],
                        formato: ['dct:format'],
                        licencia: ['dct:license'],
                        derechos: ['dct:rights'],
                        descripcion_distribucion: ['dcat:distribution']
                    };

                    let matched = false;
                    const literalRegex = /([A-Za-z0-9_-]+:[A-Za-z0-9_-]+)\s+"([^"]+)"/g;
                    let match;
                    while ((match = literalRegex.exec(stored)) !== null) {
                        const predicate = match[1];
                        const value = match[2];
                        Object.entries(turtleMap).forEach(([fieldName, predicates]) => {
                            if (predicates.includes(predicate)) {
                                setValueIfEmpty(fieldName, value);
                                matched = true;
                            }
                        });
                    }
                    return matched;
                };

                const parseCsvLine = (line) => {
                    const result = [];
                    let current = '';
                    let inQuotes = false;

                    for (let i = 0; i < line.length; i++) {
                        const char = line[i];
                        const nextChar = line[i + 1];

                        if (char === '"') {
                            if (inQuotes && nextChar === '"') {
                                current += '"';
                                i++;
                            } else {
                                inQuotes = !inQuotes;
                            }
                        } else if ((char === ',' || char === ';') && !inQuotes) {
                            result.push(current.trim());
                            current = '';
                        } else {
                            current += char;
                        }
                    }
                    result.push(current.trim());
                    return result;
                };

                const attemptCsv = () => {
                    const lines = stored.split(/\r?\n/).filter(line => line.trim().length > 0);
                    if (lines.length < 2) return false;

                    const delimiter = (lines[0].match(/;/g) || []).length > (lines[0].match(/,/g) || []).length ? ';' : ',';

                    const headers = parseCsvLine(lines[0]).map(h => h.replace(/^"|"$/g, '').trim().toLowerCase());
                    const values = parseCsvLine(lines[1]).map(v => v.replace(/^"|"$/g, '').trim());

                    if (!headers.length || headers.length !== values.length) return false;

                    const csvMap = {
                        identificador: ['identificador', 'identifier', 'id'],
                        titulo: ['titulo', 'title', 'name'],
                        descripcion: ['descripcion', 'description'],
                        dcat_type: ['dcat_type', 'type'],
                        idioma: ['idioma', 'language'],
                        tema: ['tema', 'theme', 'subject'],
                        extension_temporal: ['extension_temporal', 'temporal'],
                        extension_espacial: ['extension_espacial', 'spatial'],
                        url_descarga: ['url_descarga', 'download_url', 'downloadurl'],
                        issued: ['issued', 'fecha_publicacion', 'published'],
                        modificado: ['modificado', 'modified', 'updated'],
                        publisher_name: ['publisher', 'publisher_name'],
                        url_acceso: ['url_acceso', 'access_url', 'accessurl'],
                        formato: ['formato', 'format'],
                        licencia: ['licencia', 'license'],
                        derechos: ['derechos', 'rights'],
                        descripcion_distribucion: ['descripcion_distribucion', 'distribution_description']
                    };

                    let found = false;
                    Object.entries(csvMap).forEach(([fieldName, keys]) => {
                        keys.forEach(key => {
                            const idx = headers.indexOf(key);
                            if (idx !== -1 && idx < values.length) {
                                const value = values[idx];
                                if (value) {
                                    setValueIfEmpty(fieldName, value);
                                    found = true;
                                }
                            }
                        });
                    });
                    return found;
                };

                const attemptPlain = () => {
                    const lines = stored.split(/\r?\n/);
                    lines.forEach(line => {
                        const [maybeKey, ...rest] = line.split(':');
                        if (!maybeKey || !rest.length) return;
                        const key = maybeKey.trim().toLowerCase();
                        const value = rest.join(':').trim();
                        if (!value) return;
                        Object.entries(fieldMapping).forEach(([fieldName, keys]) => {
                            if (keys.includes(key)) {
                                setValueIfEmpty(fieldName, value);
                            }
                        });
                    });
                    return applied;
                };

                const strategies = [];
                if (formatHint.includes('json')) strategies.push(attemptJson);
                if (formatHint.includes('rdf-xml') || formatHint.includes('xml')) strategies.push(attemptXml);
                if (formatHint.includes('rdf-turtle') || formatHint.includes('turtle')) strategies.push(attemptTurtle);
                if (formatHint.includes('csv')) strategies.push(attemptCsv);

                // Fallback attempts, por si el archivo no coincide con la pista
                strategies.push(attemptJson, attemptXml, attemptTurtle, attemptCsv, attemptPlain);

                for (const strategy of strategies) {
                    if (strategy()) break;
                }
            };

            tryPrefill();

            if (form) {
                form.addEventListener('submit', function (e) {
                    // Recuperar archivos guardados en sessionStorage
                    const storedFiles = sessionStorage.getItem('datasetFiles');
                    if (storedFiles) {
                        try {
                            let filesInput = form.querySelector('input[name="dataset_files_data"]');
                            if (!filesInput) {
                                filesInput = document.createElement('input');
                                filesInput.type = 'hidden';
                                filesInput.name = 'dataset_files_data';
                                form.appendChild(filesInput);
                            }
                            filesInput.value = storedFiles;
                        } catch (err) {
                            // Silenciar errores
                        }
                    }
                    sessionStorage.removeItem('metadataFileContent');
                    sessionStorage.removeItem('datasetFiles');
                });
            }
        })();

        // Generaci贸n y descarga del archivo Turtle con los metadatos actuales
        (function () {
            const form = document.querySelector('.formulario');
            const downloadBtn = document.getElementById('descargar-turtle');
            if (!form || !downloadBtn) return;

            downloadBtn.addEventListener('click', async function () {
                const formData = new FormData(form);
                const metadataField = document.getElementById('metadata-content-field');
                if (metadataField) {
                    formData.set('metadata_content', metadataField.value || '');
                }

                try {
                    const response = await fetch("{% url 'generar_turtle' %}", {
                        method: 'POST',
                        body: formData,
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(errorText || 'Error al generar el archivo Turtle.');
                    }

                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const enlace = document.createElement('a');
                    const baseName = formData.get('identificador') || formData.get('name') || 'metadatos';
                    enlace.href = url;
                    enlace.download = `${baseName || 'metadatos'}.ttl`;
                    document.body.appendChild(enlace);
                    enlace.click();
                    enlace.remove();
                    window.URL.revokeObjectURL(url);
                } catch (err) {
                    alert('No se pudo generar el archivo Turtle: ' + err.message);
                }
            });
        })();
    </script>
    <script src="{% static 'web/js/ckan_integration.js' %}"></script>
</body>

</html>